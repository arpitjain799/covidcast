# Advanced examples

## Returning complex objects

As a final example, we show how to use `slide_by_geo()` to output more complex
objects. We amend the last example so that `dv_regression()` returns both the
predicted value (sensor) and the fitted linear model object. In order to use 
this with `slide_by_geo()`, we need to set the `col_type` argument to be "list":

```{r}
dv_regression <- function(x, m = 3, ...){
  n <- nrow(x)
  if ( n <= m+1 ) return(list(lm_obj = NA, sensor = NA)) # Trivial case
  
  return(tryCatch(suppressWarnings(suppressMessages({
    # Fit a regression, leaving out the last days of data
    n <- nrow(x)
    lm_obj <- lm(value.y ~ value.x, data = x[1:(n-m+1), ])
    
    # Form prediction for the last day of data
    sensor <- predict(lm_obj, newdata = x[n, ])
    
    # Return the fitted lm object and prediction
    list(lm_obj = lm_obj, sensor = sensor)
  })),
  error = function(e) return(list(lm_obj = NA, sensor = NA))))
}

joined <- slide_by_geo(joined, slide_fun = dv_regression, n = 56, m = 3, 
                       col_name = "sensor_obj", col_type = "list")

class(joined$sensor_obj)
names(joined$sensor_obj[[5]]) # The first 4 are lists filled with NAs
joined$sensor_obj[[5]]$lm_obj
joined$sensor_obj[[5]]$sensor
```

This allows for post-inspection of the sensor models, which may be helpful for
diagnostic purposes. Note the way in which we structure the return argument in 
`dv_regression()` in its failure cases: it is always a list with the same named
arguments. This helps keep the post-inspection code just a bit more simple (it
is already a hairy enough, to protect against extracting coefficients from `NA` 
objects).

```{r}
joined %>% 
  rowwise() %>%
  mutate(sensor = sensor_obj$sensor, 
         intercept = ifelse(isTRUE(is.na(sensor_obj$lm_obj)), NA,
                            coef(sensor_obj$lm_obj)[1]),
         slope = ifelse(isTRUE(is.na(sensor_obj$lm_obj)), NA, 
                        coef(sensor_obj$lm_obj)[2])) %>%
  select(geo_value, time_value, sensor, intercept, slope) %>%
  arrange(geo_value) %>% 
  head(n = 10) %>%
  kable(format = "html", digits = 3)
```


## Post-hoc inspection

In the call to `estimate_deriv()`, we can set `keep_obj = TRUE` to keep around a
second column with the fitted model objects. For example, here, we can look at 
the p-values associated with the estimated slopes from `lsfit()`. 

```{r}
case_rates <- estimate_deriv(case_rates, method = "lin", n = 14, 
                             keep_obj = TRUE)

class(case_rates$deriv_obj)
ls.print(case_rates$deriv_obj[[7]])
         
case_rates <- case_rates %>%
  rowwise() %>%
  mutate(p_value = quiet(
    tryCatch(ls.print(deriv_obj)$coef.table[[1]][2,"Pr(>|t|)"], 
             error = function(e) NA))) 

case_rates %>% 
  arrange(geo_value) %>% 
  select(geo_value, time_value, value, deriv, deriv_obj, p_value)
```
