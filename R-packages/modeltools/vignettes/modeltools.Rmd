---
title: Getting started with modeltools
description: An introductory tutorial with examples.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with modeltools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
```

## Installing

<font size="3">**_Warning_: This package is not on CRAN!**</font><br/><br/>
An <tt>R</tt> package named "`modeltools`" does exist on CRAN, but it is
entirely unrelated to this one. Delphi's `modeltools` 
package can be installed from the Delphi research group
[**GitHub page**](https://github.com/cmu-delphi/) using the
[`devtools`](https://cran.r-project.org/package=devtools) package, as shown
below. The package's source code can be found
[**here**](https://github.com/cmu-delphi/covidcast/tree/main/R-packages/modeltools).


### Installing with vignettes

If you would like to install the `modeltools` package with tutorial 
vignettes included (recommended), then use the following command:

```{r, eval = FALSE}
devtools::install_github(repo = "cmu-delphi/covidcast", ref = "collin-develop",
                         subdir = "R-packages/modeltools",
                         build_vignettes = TRUE, dependencies = TRUE)
```


### Installing without vignettes

Building the vignettes for Delphi's 
[`covidcast`](https://cmu-delphi.github.io/covidcast/covidcastR/) 
package (a `modeltools` dependency) causes the above installation to take a 
couple minutes. If you prefer a quick installation, you can install `modeltools`
without vignettes (the default setting):

```{r, eval = FALSE}
devtools::install_github(repo = "cmu-delphi/covidcast", ref = "collin-develop",
                         subdir = "R-packages/modeltools")
```
<br />


## Downloading data from Delphi's COVIDcast Epidata API

In this **Getting started** vignette, we'll fetch daily COVID-19 case 
rate reporting data (i.e. the number of new COVID-19 cases reported per day, 
per 100,000 population) from Delphi's
[**COVIDcast Epidata API**](https://cmu-delphi.github.io/delphi-epidata/api/covidcast_signals.html).
The cases rates we'll examine here are reported by
[**USAFacts**](https://usafacts.org/)
and cloned into Delphi's API every day. As with many other signals, the API 
also stores a smoothed version of the signal --- a 7-day trailing average of 
the (raw) daily case rates reported by USAFacts. 
Here, we'll look at both the raw and smoothed USAFacts case rates 
from June 1, 2020 through November 15, 2020 for four U.S. states --- CA, FL,
NY, and TX.

```{r message = FALSE}
library(covidcast)

start_day <- "2020-06-01"
end_day <- "2020-11-15"
geo_values <- c("ca", "fl", "ny", "tx")

signals <- covidcast_signals(data_source = "usa-facts",
                             signal = c("confirmed_incidence_prop",
                                        "confirmed_7dav_incidence_prop"),
                             start_day = start_day,
                             end_day = end_day,
                             geo_type = "state", 
                             geo_values = geo_values)
```
<br />

By default, the 
[`covidcast_signals()`](https://cmu-delphi.github.io/covidcast/covidcastR/reference/covidcast_signals.html)
function returns the requested signals as 
a list of `covidcast_signal` data frames, with one data frame for each signal. The 
[`summary()`](https://cmu-delphi.github.io/covidcast/covidcastR/reference/summary.covidcast_signal.html)
function can be called on each of these `covidcast_signal` data frames, as 
below.

```{r collapse = TRUE}
summary(signals[[1]])

summary(signals[[2]])
```
<br />

As shown in the summary output above, each of the fetched `covidcast_signal` data 
frames in the list has 12 columns. Here, we'll only need the 5 columns selected 
below. A full description of the USAFacts reporting data stored in Delphi's API
can be found 
[here](https://cmu-delphi.github.io/delphi-epidata/api/covidcast-signals/usa-facts.html).

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# Function for displaying nice html table heads
library(knitr)
library(kableExtra)
table_head <- function(x, nrows = 6, title = NULL, footnote = NULL){

  kbl.out <- x %>%
    head(nrows) %>%
    kbl(format = "html", digits = 3) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
  
  if ( !is.null(title) ){
    header <- ncol(x)
    names(header) <- title
    kbl.out <- kbl.out %>% add_header_above(header, font_size = 15, line = F)
  }
  if ( !is.null(footnote) ){
    kbl.out <- kbl.out %>% add_footnote(footnote, notation = "symbol")
  }
  if ( nrows > 20 ){
    kbl.out <- kbl.out %>% 
      scroll_box(width = "100%", height = "300px", box_css = "border: 0px solid #fff; padding: 2px; ")
  }
  return(kbl.out)
}
```

```{r, message = FALSE, warning = FALSE}
library(dplyr)
signals[[1]] <- signals[[1]] %>% select(data_source, signal, geo_value, time_value, value)
signals[[2]] <- signals[[2]] %>% select(data_source, signal, geo_value, time_value, value)

signals[[1]] %>% table_head(title = "Daily COVID-19 cases per 100,000 pop. (reported values)")
signals[[2]] %>% table_head(title = "Daily COVID-19 cases per 100,000 pop. (7-day trailing average)")
```

The `table_head` function used above is a custom function that we use in 
these tutorial vignettes to display
table heads. The source code can be found in the 
[`vignettes/modeltools.Rmd`](modeltools.Rmd) 
file used to build this page.


## Sliding

One of the most basic tools in the `modeltools` package is the `slide_by_geo()`
function, which is based on the family of functions provided by the 
[`slider`](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)
package. 

>**Definition:** In `modeltools`, to *slide* means that, for each `geo_value`, we 
apply a user-specified function or formula over a trailing window of `n` days of 
data.

Many other functions in this package, such as `pct_change()` and 
`estimate_deriv()`, use `slide_by_geo()` as their workhorse. Below we provide
some examples of performing sliding operations on `covidcast` signals with 
`slide_by_geo()`, utilizing both the function and formula options.
<br/>


### Sliding with a formula

#### Example 1: Computing a 7-day trailing average by sliding a formula

In this example we reproduce the calculation of the smoothed daily case rates 
that is performed by the Delphi API.
This can be done by passing the `covidcast_signal` data frame of raw daily case
rates (`signals[[1]]`) to `slide_by_geo()` and then passing a 7-day trailing
average formula to the `slide_fun` argument, as follows:

```{r, message = FALSE, warning = FALSE}
library(modeltools)

slide_by_geo(signals[[1]], slide_fun = ~ Mean(.x$value), n = 7) %>%
  table_head(title = "Daily COVID-19 cases per 100,000 pop. (7-day trailing average)")
```
<br />

The formula specified by `slide_fun` has access to all columns present in the
original `covidcast_signal` data frame, and must be referred to with the prefix
`.x$`. Here, the function `modeltools::Mean()` is a simple wrapper around 
`mean()` that omits `NA` values by default.

Notice that the above `slide_by_geo()` call returns a data frame with a new 
column appended that contains the results of the sliding operation specified by
`slide_fun`. By default, this column is named `"slide_value"`, but alternate
names can be passed to `slide_by_geo()`, as follows: 

```{r}
slide_by_geo(signals[[1]], slide_fun = ~ Mean(.x$value), n = 7, col_name = "7dav") %>%
  table_head(title = "Daily COVID-19 cases per 100,000 pop. (7-day trailing average)")
```
<br />

Since this example is meant to reproduce the 7-day trailing average calculation 
carried out by the Delphi API, the values in the `7dav` column should match the 
pre-computed smoothed daily case rates signal stored in the API 
(to machine precision). To check this, the code chunk below calculates the 
maximum absolute difference between the two 7-day trailing averages, 
over all state-date pairs:
$$\big\{\text{CA, FL, NY, TX}\big\} \times \big\{\text{date}: \text{date}\in \{\text{June 7, 2020, }\dots,\text{ November 15, 2020}\}\big\}.$$

```{r, collapse = TRUE}
slide_by_geo(signals[[1]], slide_fun = ~ Mean(.x$value), n = 7, col_name = "7dav") %>%
  full_join(signals[[2]], by = c("geo_value", "time_value")) %>%
  mutate(difference = `7dav` - value.y) %>%
  filter(time_value >= "2020-06-07") %>%
  summarize(max(abs(difference))) %>%
  as.numeric
```

The trivial output of this calculation confirms that `slide_by_geo()` is 
functioning as desired. 
<br /><br />

**Note:** The raw daily case rates that we pass to `slide_by_geo()` begin on 
June 1, 2020, so the `"7dav"` column created by `slide_by_geo()` doesn't 
represent a true *7-day average* until June 7, 2020. This is why we only 
perform the sanity check calculation above on the dates June 7, 2020, ...,
November 15, 2020. When a trailing window of `n` days is not available, 
`slide_by_geo()` just applies the `slide_fun` function/formula to whatever data 
*is* available. So for June `n`th, `n = 1,...,6`, the values in the `"7dav"` 
column are only `n`-day trailing averages. Whereas the pre-computed smoothed 
daily case rates signal stored in Delphi's API is a true 7-day average for 
all dates June 1, 2020, ..., November 15, 2020.



### Sliding with a function 

We can also pass a function to the `slide_fun` argument in `slide_by_geo()`. In 
this case, the passed function must have the following input argument structure: 

1. `x` : a data frame with the same column names as the data frame passed to
`slide_by_geo()`

2. Any number of additional **named** arguments

3. An ellipsis `...` to allow for any number of additional general arguments

#### Example 2: Computing a 7-day trailing average by sliding a function

The code chunk below reproduces the 7-day trailing average from
[**Example 1**][Example 1: Computing a 7-day trailing average by sliding a formula], 
but passes a function to the `slide_fun` argument instead of a formula.

```{r}
slide_by_geo(signals[[1]], slide_fun = function(x, ...) Mean(x$value), n = 7, col_name = "7dav") %>%
  table_head(title = "Daily COVID-19 cases per 100,000 pop. (7-day trailing average)")
```
<br />

#### Example 3 (advanced):

As a more sophisticated example, here we show how to *sensorize* the 
[doctor visits signal](https://cmu-delphi.github.io/delphi-epidata/api/covidcast-signals/doctor-visits.html)
stored in the API, which is provided to Delphi by health system partners. 

Estimated percentage of outpatient doctor visits primarily about COVID-related symptoms

The 
sensor values are defined by the predicted values of a local (in time) 
regression, where doctor visits are used to predict case rates.

Perform sensorization for each state; use the last n = 56 days (8 weeks) of 
data, minus the last m = 3 days, for the regression.

problems with “cases” in terms of delays, biases, etc.


```{r message = FALSE, warning = FALSE, eval = FALSE}
predict_case_rates <- function(data, m = 3) {
  n <- nrow(data)
  if ( n <= m ) return(NA)
  lm_obj <- lm(y ~ x, data = data[1:(n - m), ])
  return(predict(lm_obj, newdata = data[n, ]))
}

df <- covidcast_signals(data_source = c("doctor-visits", "usa-facts"),
                        signal = c("smoothed_adj_cli", "confirmed_7dav_incidence_prop"),
                        start_day = start_day,
                        end_day = end_day,
                        geo_type = "state",
                        geo_values = geo_values) %>%
  aggregate_signals %>%
  rename(x = `value+0:doctor-visits_smoothed_adj_cli`,
         y = `value+0:usa-facts_confirmed_7dav_incidence_prop`)

slide_by_geo(df, slide_fun = predict_case_rates, n = 56) %>%
  select(geo_value, time_value, `doctor-visits-cli`, `reported-case-rates-7dav`, 
         `predicted-case-rates-7dav`) %>%
  arrange(geo_value) %>% 
  table_head(nrows = 100)
```

The first 4 values of the sensor column `"predicted-case-rates-7dav"` are 
`NA` because of insufficient training data.
(we need at least 2 training samples to fit the simple linear 
regression, and we omit the last `m = 3` days of data).
