---
title: Get started with `modeltools`
description: An introductory tutorial with examples.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started with `modeltools`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
```

This package provides tools for building COVID-19 statistical models, with an 
emphasis on short-term forecasting and hotspot prediction. It is designed to be 
used in conjunction with the 
[`covidcast`](https://cmu-delphi.github.io/covidcast/covidcastR/) and 
[`evalcast`](https://cmu-delphi.github.io/covidcast/evalcastR/) \
<tt>R</tt> packages, which are also developed and maintained by the 
[Delphi research group](https://delphi.cmu.edu) (headquartered at 
Carnegie Mellon University).


## Installing

**This package is not on CRAN. There is a package named `modeltools` on 
CRAN, but it is entirely unrelated to this one.**

This package is available on the Delphi research group's [GitHub 
page](https://github.com/cmu-delphi) and can be installed using the
[`devtools`](https://cran.r-project.org/package=devtools) package, as shown
below.


### Installing without vignettes

Building the `modeltools` vignettes, such as this *Getting started guide*, 
takes a significant amount of time. So, by default, the vignettes are not 
included in the installed package. The vignette-less package can be installed
with the following command:

```{r, eval = FALSE}
devtools::install_github(repo = "cmu-delphi/covidcast", ref = "collin-develop",
                         subdir = "R-packages/modeltools")
```


### Installing with vignettes

If you wish to include the vignettes, then use the command below. Installation
can take a couple minutes.

```{r, eval = FALSE}
devtools::install_github(repo = "cmu-delphi/covidcast", ref = "collin-develop",
                         subdir = "R-packages/modeltools",
                         build_vignettes = TRUE, dependencies = TRUE)
```


## Downloading data from the `covidcast` API

For this *Getting started* vignette, we will fetch U.S. COVID-19 case rates --- 
both raw and smoothed with 7-day trailing averages --- from the [Delphi 
API](https://cmu-delphi.github.io/delphi-epidata/api/covidcast_signals.html). 
These particular COVID-19 data signals are reported by the 
[*USAFacts*](https://cmu-delphi.github.io/delphi-epidata/api/covidcast-signals/usa-facts.html)
data source and then cloned into the Delphi API. Here, we will download the 
signals at the state level for four states over the time window June 1, 2020 to 
November 15, 2020.

```{r message = FALSE}
library(covidcast)

start_day <- "2020-06-01"
end_day <- "2020-11-15"
geo_values <- c("ca", "fl", "ny", "tx")

signals <- covidcast_signals(data_source = "usa-facts",
                             signal = c("confirmed_incidence_prop",
                                        "confirmed_7dav_incidence_prop"),
                             start_day = start_day,
                             end_day = end_day,
                             geo_type = "state", 
                             geo_values = geo_values)
```

By default, the `covidcast_signals()` function returns the specified signals as 
a list of `covidcast_signal` data frames, with one data frame for each signal. 
So, in this case, `signals` is a list of two `covidcast_signal` data frames ---
the first being the raw COVID-19 case rates and the second being the COVID-19 
case rates after smoothing with a 7-day trailing average. The `summary()` 
function can be called on each of these `covidcast_signal` data frames as 
follows:

```{r collapse = TRUE}
summary(signals[[1]])

summary(signals[[2]])
```

Taking a peek at each of the `covidcast_signal` data frames in the list:

```{r, message = FALSE, warning = FALSE, fig.align = 'center'}
library(dplyr)
library(knitr)

signals[[1]] %>%
  select(data_source, signal, geo_value, time_value, value) %>% 
  head(5) %>%
  kable(format = "html", digits = 3, align = "c",
        caption = "U.S. COVID-19 case rates (raw)")

signals[[2]] %>%
  select(data_source, signal, geo_value, time_value, value) %>% 
  head(5) %>%
  kable("html", digits = 3, align = "c",
        caption = "U.S. COVID-19 case rates (7-day trailing average)")
```


## Sliding

One of the most basic tools in the `modeltools` package is the `slide_by_geo()`
function which is based on the family of functions provided by the `slider` 
package. 

>**Definition: In `modeltools`, to *slide* means, for each `geo_value`, we apply 
a user-specified function or formula over a trailing window of `n` days of 
data.**

Many other functions in the package, such as `pct_change()` and 
`estimate_deriv()`, use `slide_by_geo()` as their workhorse. 


### Sliding with a formula

#### Example 1: Computing a 7-day trailing average by sliding a formula over the raw data

For example, to apply a 7-day trailing average to the raw values in the first
`covidcast_signal` data frame fetched above (i.e. `signals[[1]]`), we can 
specify a formula via the `slide_fun` argument of `slide_by_geo()`:

```{r, message = FALSE, warning = FALSE}
library(modeltools)
library(dplyr)
library(knitr)

slide_by_geo(signals[[1]], slide_fun = ~ Mean(.x$value), n = 7) %>%
  select(geo_value, time_value, value, slide_value) %>%
  arrange(geo_value) %>%
  head(10) %>%
  kable(format = "html", digits = 3, align = "c",
        caption = paste("U.S. COVID-19 case rates (7-day trailing average computed by sliding",
                        "a formula)"))
```

The formula specified by `slide_fun` has access to all columns present in the
original `covidcast_signal` data frame, and must be referred to with the prefix
`.x$`. Here, the function `Mean()` is a simple wrapper around `mean()` that 
omits `NA` values by default (provided by the `modeltools` package). 

Notice that the above `slide_by_geo()` call returns a data frame with a new 
column appended that contains the results of the sliding operation specified by
`slide_fun`. This column is named `"slide_value"` by default, but alternative
namings can be used by passing a string to the `col_name` argument in the 
original `slide_by_geo()` function call. For example: 

```{r}
slide_by_geo(signals[[1]], slide_fun = ~ Mean(.x$value), n = 7, col_name = "7dav") %>%
  select(geo_value, time_value, value, `7dav`) %>%
  arrange(geo_value) %>% 
  head(10) %>%
  kable(format = "html", digits = 3, align = "c",
        caption = paste("U.S. COVID-19 case rates (7-day trailing average computed by sliding",
                        "a formula)"))
```

As a simple sanity check, we compare the 7-day trailing average computed via
`slide_by_geo()` to the values of the smoothed signal from the API to ensure
that they match (to machine precision). More specifically, the code chunk
below computes the maximum absolute difference between the two 7-day averaged 
signals, over all state-date pairs.

```{r, collapse = TRUE}
slide_by_geo(signals[[1]], slide_fun = ~ Mean(.x$value), n = 7, col_name = "7dav") %>%
  full_join(signals[[2]], by = c("geo_value", "time_value")) %>%
  mutate(difference = `7dav` - value.y) %>%
  filter(time_value >= "2020-06-07") %>%
  summarize(max(abs(difference))) %>%
  as.numeric
```

The output of this sanity check confirms `slide_by_geo()` is functioning
as desired.

**Note:** This sanity check would *fail* without filtering the dates to 
`>= "2020-06-07"` because the Delphi API has access to data before June 1, 2020,
and can therefore return the trailing 7-day average for all days in the time 
window June 1, 2020 to November 15, 2020. On the other hand, since we are
only providing `slide_by_geo()` with daily COVID-19 case rates beginning on June
1, 2020, the trailing 7-day average computed by `slide_by_geo()` is not a true 
7-day average until June 7, 2020. When a trailing window of `n` days isn't 
available, `slide_by_geo()` just applies the function or formula to whatever 
data is available.


### Sliding with a function 

We can also pass a function to the `slide_fun` argument in `slide_by_geo()`. In 
this case, the passed function must have the following input argument structure: 

1. `x` : a data frame with the same column names as the data frame passed to
`slide_by_geo()`

2. Any number of additional **named** arguments

3. An ellipsis `...` to allow for any number of additional general arguments

#### Example 2: Computing a 7-day trailing average by sliding a function over the raw data

The code chunk below recreates Example 1, but passes a function to the 
`slide_fun` argument instead of a formula.

```{r}
slide_by_geo(signals[[1]], slide_fun = function(x, ...) Mean(x$value), n = 7, col_name = "7dav") %>%
  select(geo_value, time_value, value, `7dav`) %>%
  arrange(geo_value) %>% 
  head(10) %>%
  kable(format = "html", digits = 3, align = "c",
        caption = paste("U.S. COVID-19 case rates (7-day trailing average computed by sliding",
                        "a function)"))
```


#### Example 3 (advanced):

As a more sophisticated example, here we show how to *sensorize* the doctor 
visits signal. The sensor values are defined by the predicted values from a 
local (in time) regression of past case rates (response) on past doctor visits 
(covariate).

```{r message = FALSE}
# Regression for doctor visits sensorization
dv_regression <- function(x, m = 3, ...) {
  n <- nrow(x)
  if ( n <= m + 1 ) return(NA) # Take care of trivial case
  
  return(tryCatch(suppressWarnings(suppressMessages({
    # Fit a regression, leaving out the last m days of data
    lm_obj <- lm(value.y ~ value.x, data = x[1:(n-m+1), ])
    
    # Form prediction for the last day of data, and return
    predict(lm_obj, newdata = x[n, ])
  })),
  error = function(e) return(NA)))
}

# Fetch doctor visits signal and join it to case rates
joined <- covidcast_signal(data_source = "doctor-visits",
                           signal = "smoothed_adj_cli",
                           start_day = start_day, 
                           end_day = end_day,
                           geo_type = "state", 
                           geo_values = geo_values) %>%
  full_join(signals[[2]], by = c("geo_value", "time_value"))
 
# Perform sensorization for each state; use the last n = 56 days (8 weeks) of 
# data, minus the last m = 3 days, for the regression
slide_by_geo(joined, slide_fun = dv_regression, n = 56, m = 3, 
             col_name = "sensor") %>%
  select(geo_value, time_value, value.x, value.y, sensor) %>%
  arrange(geo_value) %>% 
  head(10) %>%
  kable(format = "html", align = "c", digits = 3)
```

Above, the first 4 elements are `NA` because of insufficient training data (we 
need at least 2 training samples for simple linear regression, and we omit the 
last 3 days of data).
